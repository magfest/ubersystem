import cherrypy
from datetime import datetime
from pockets.autolog import log
from pytz import UTC
from sqlalchemy.orm import subqueryload

from uber.config import c
from uber.custom_tags import pluralize
from uber.decorators import ajax, all_renderable, render
from uber.errors import HTTPRedirect
from uber.models import Attendee, Group
from uber.payments import ReceiptManager
from uber.tasks.email import send_email
from uber.utils import remove_opt, SignNowRequest


def convert_dealer_badge(session, attendee, admin_note=''):
    """
    Takes a dealer badge and converts it to an attendee badge. This does NOT remove the badge from the group, as
    keeping the badge with the group is important if the group is still waitlisted or for events that import badges.
    Instead, it removes their Dealer ribbon and sets them to no longer being paid by group, then updates or creates
    their receipt accordingly.
    """

    receipt = session.get_receipt_by_model(attendee)
    receipt_items = []
    params = {
        'ribbon': remove_opt(attendee.ribbon_ints, c.DEALER_RIBBON),
        'badge_cost': None,
    }

    if attendee.paid not in [c.HAS_PAID, c.NEED_NOT_PAY]:
        params['paid'] = c.NOT_PAID
        params['badge_status'] = c.NEW_STATUS
        params['overridden_price'] = c.get_attendee_price(attendee.registered_local)
        attendee.can_transfer = False

    receipt_items = ReceiptManager.auto_update_receipt(attendee, receipt, params)

    for key, val in params.items():
        setattr(attendee, key, val)

    # Helps track whether or not the badge has been 'claimed'
    attendee.placeholder = True

    session.add(attendee)
    session.commit()

    if admin_note:
        attendee.append_admin_note(admin_note)

    if receipt:
        session.add_all([item for item in receipt_items if item.amount != 0])
    else:
        session.get_receipt_by_model(attendee, create_if_none="DEFAULT")


def decline_and_convert_dealer_group(session, group, status=c.DECLINED, admin_note='',
                                     email_leader=True, delete_group=False):
    from uber.models import AdminAccount
    """
    Cancels a dealer group and converts its assigned badges to individual badges that can be purchased for
    the attendee price at the time they registered.
    `group` is the group to convert.
    `status` sets the status for the group.
    `admin_note` defines the admin note to append to every converted attendee. If blank, a note is generated
        based on the current logged-in admin.
    `email_leader` controls whether or not the group leader is emailed. Set to False for any calls to this
        function generated by the group leader, e.g., the Cancel Application button on the group members page.
    `delete_group` removes all assigned attendees from the group and deletes it instead of changing its status.
        This is best for cases where the number of declined groups fed to this function is enormous and you
        are very sure you will never need to look at them again.
    """
    group.status = status
    if not admin_note:
        if status == c.WAITLISTED:
            admin_note = (f'Converted badge from {AdminAccount.admin_name() or "server admin"} '
                          f'closing waitlist for {c.DEALER_REG_TERM} "{group.name}".')
        elif delete_group:
            admin_note = (f'Converted badge from {AdminAccount.admin_name() or "server admin"} '
                          f'declining and converting {c.DEALER_REG_TERM} "{group.name}".')
        else:
            admin_note = (f'Converted badge from {AdminAccount.admin_name() or "non-admin"} '
                          f'setting {c.DEALER_REG_TERM} "{group.name}" to {group.status_label}.')
    if not group.is_unpaid:
        group.tables = 0
        for attendee in group.attendees:
            attendee.append_admin_note(admin_note)
            attendee.ribbon = remove_opt(attendee.ribbon_ints, c.DEALER_RIBBON)
        return 'Group {} status removed'.format(c.DEALER_TERM)

    if status == c.WAITLISTED:
        email_subject = f"{c.EVENT_NAME} {c.DEALER_LOC_TERM.title()} Waitlist Has Been Exhausted"
    else:
        email_subject = f"Update About Your {c.EVENT_NAME} Registration"
    message = ['Group declined']
    emails_failed = 0
    emails_sent = 0
    badges_converted = 0
    assigned_badges = group.badges - group.unregistered_badges

    for attendee in list(group.attendees):
        if not attendee.is_unassigned:
            convert_dealer_badge(session, attendee, admin_note)
            if email_leader or attendee != group.leader:
                try:
                    send_email.delay(
                        c.MARKETPLACE_EMAIL,
                        attendee.email_to_address,
                        email_subject,
                        render('emails/dealers/badge_converted.html', {
                            'attendee': attendee,
                            'group': group,
                            'other_badges': assigned_badges - 1}, encoding=None),
                        format='html',
                        model=attendee.to_dict('id'))
                    emails_sent += 1
                except Exception as e:
                    log.error(f"Failed to send badge conversion email: {str(e)}")
                    emails_failed += 1

            badges_converted += 1
        elif not delete_group:
            attendee.badge_status = c.INVALID_GROUP_STATUS
            attendee.paid = c.NOT_PAID
        else:
            session.delete(attendee)

        if delete_group:
            attendee.group = None
            attendee.group_id = None

        session.add(attendee)
        session.commit()

    if delete_group:
        group.leader = None
        session.delete(group)

    for count, template in [
            (badges_converted, '{} badge{} converted'),
            (emails_sent, '{} email{} sent'),
            (emails_failed, '{} email{} failed to send')]:
        if count > 0:
            message.append(template.format(count, pluralize(count)))
    return ', '.join(message)


@all_renderable()
class Root:
    def index(self, session, message=''):
        HTTPRedirect('../group_admin/index#dealers?message={}', message)

    def waitlist(self, session, decline_and_convert=False):
        query = session.query(Group).filter(
            Group.tables > 0,
            Group.status == c.WAITLISTED).order_by(Group.name, Group.id)

        if cherrypy.request.method == 'POST':
            groups = query.options(
                subqueryload(Group.attendees).subqueryload(Attendee.admin_account),
                subqueryload(Group.attendees).subqueryload(Attendee.shifts)).all()

            message = ''
            if decline_and_convert:
                for group in groups:
                    decline_and_convert_dealer_group(session, group, status=c.WAITLISTED,
                                                     delete_group=c.DELETE_DECLINED_GROUPS)
                message = 'All waitlisted {}s have been declined and converted to regular attendee badges'\
                    .format(c.DEALER_TERM)
            raise HTTPRedirect('../group_admin/index?message={}#dealers', message)

        return {'groups': query.all()}
    
    def convert_declined(self, session, **params):
        declined_groups = session.query(Group).filter(Group.status == c.DECLINED)
        for group in declined_groups:
            session.add(group)
            group.convert_badges = True
        raise HTTPRedirect('../group_admin/index?message={}#dealers', "All declined groups marked for badge conversion.")
    
    def convert_example(self, session, id, **params):
        from uber.models import Email

        group = session.group(id)
        old_status = group.status
        group.status = c.DECLINED
        assigned_badges = group.badges - group.unregistered_badges
        example_attendee = group.leader if group.leader else [a for a in self.attendees if not a.is_unassigned][0]
        body = render('emails/dealers/badge_converted.html',
                      {'attendee': example_attendee,
                       'group': group,
                       'other_badges': assigned_badges - 1}, encoding=None)
        example = Email(
                    subject=f"Update About Your {c.EVENT_NAME} Registration",
                    body=body,
                    sender=c.MARKETPLACE_EMAIL,
                    to=example_attendee.email_to_address,
                    ident='convert_badge_email',
                    fk_id=example_attendee.id,
                )
        group.status = old_status

        return {'group': group, 'example_attendee': example_attendee, 'example': example}
    
    def dealer_statuses(self, session, id, **params):
        group = session.group(id)
        return {'group': group}

    @ajax
    def unapprove(self, session, id, action, email_text, convert=False, message=''):
        assert action in ['waitlisted', 'declined']
        group = session.group(id)
        subject = 'Your {} {} has been {}'.format(c.EVENT_NAME, c.DEALER_REG_TERM, action)
        if group.email:
            send_email.delay(
                c.MARKETPLACE_EMAIL,
                group.email_to_address,
                subject,
                email_text,
                bcc=c.MARKETPLACE_NOTIFICATIONS_EMAIL,
                model=group.to_dict('id'))
        if action == 'waitlisted':
            group.status = c.WAITLISTED
        elif convert == True:
            message = decline_and_convert_dealer_group(session, group)
        else:
            group.status = c.DECLINED
        session.commit()
        return {'success': True,
                'message': message}
    
    def resend_signnow_link(self, session, id):
        group = session.group(id)

        signnow_request = SignNowRequest(session=session, group=group)
        if not signnow_request.document:
            raise HTTPRedirect("../group_admin/form?id={}&message={}".format(id, "SignNow document not found."))

        signnow_request.send_dealer_signing_invite()
        if signnow_request.error_message:
            raise HTTPRedirect("../group_admin/form?id={}&message={}", id,
                               f"Error sending SignNow link: {signnow_request.error_message}")
        else:
            signnow_request.document.last_emailed = datetime.now(UTC)
            session.add(signnow_request.document)
            raise HTTPRedirect("../group_admin/form?id={}&message={}", id, "SignNow link sent!")

    @ajax
    def set_table_shared(self, session, id, shared_group_name, **params):
        group = session.group(id)

        group.status = c.SHARED
        if shared_group_name:
            try:
                group.set_shared_with_name(shared_group_name)
            except ValueError as e:
                return {'error': str(e)}

        group.convert_to_shared(session)
        session.commit()

        send_email.delay(
            c.MARKETPLACE_EMAIL,
            group.leader.email_to_address,
            f"Your {c.DEALER_APP_TERM} is now shared",
            render('emails/dealers/table_shared.html', {
                'group': group,}, encoding=None),
            format='html',
            model=group.to_dict('id'))

        return {
            'success': True,
            'message': f"This {c.DEALER_APP_TERM} is now sharing a table with {shared_group_name}."
                if shared_group_name else "Group marked as Shared."
        }
